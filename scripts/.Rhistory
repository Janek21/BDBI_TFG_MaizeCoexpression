metadata<-read.delim("../data/original_data/sample.tissue.correct.cluadj.txt", header=T, row.names=1, stringsAsFactors=TRUE)
resultDataPath<-"../"
resultMetaPath<-"../"
colnames(metadata)<-c("specie", "quality", "tissue_abv", "rep", "location")
#If dataNL is data with Length: create a row in metadata named Length as well, so that the 2 datasets can be joined, later we will remove it
if ("Length" %in% colnames(dataNL)){
metadata<-as.data.frame(t(metadata))
metadata$Length<-rep(0, nrow(metadata))
metadata<-as.data.frame(t(metadata))
metadata$specie<-as.factor(metadata$specie)
}
dataNL<-as.data.frame(t(dataNL))
datALL<-merge(dataNL, metadata, by="row.names")
rownames(datALL)<-datALL$Row.names
datALL$Row.names<-NULL
specieList<-levels(metadata$specie) #get all specie names
#In the case that its a with length dataset, remove the 0
specieList<-specieList[specieList!=0]
cat("The species are:\n", specieList)
metadata["Species","Length"]
View(datALL)
metadata[,1]
metadata[,2]
metadata[,3]
metadata[1,]
View(datALL)
datALL["Length"]
datALL["Length",]
datALL["Length",2]
a<-datALL["Length",]
View(a)
specieCreator<-function(data_joint, spName){ #selects rows of a dataset based on specie column, then splits between data and metadata
cat("\nSeparating by", spName)
data_specie<-data_joint[data_joint$specie == spName, ] #select rows according to metadata$specie column (now in joint),
#data_specie is now a single specie dataset
#Separate back to data and metadata
cat("\nSplitting data and metadata")
geneCols<-grepl("Zm", names(data_specie)) #all gene columns(data) have Zm, so we search for them
data<-data_specie[, geneCols] #data will be gene columns
metadata<-data_specie[, !geneCols] #metadata will be all that is not gene columns
#Add length to the data if it exists
if ("Length" %in% rownames(data_joint)){
lengthTotal<-data_joint["Length",] #take the full length row
lengthData<-lengthTotal[, geneCols] #Take only the columns that are genes from the row
data<-rbind(data, lengthData) #Join the full data only dataframe with the row containing the length
}
cat("\n",spName, "specie table created\n")
return(list(data, metadata))
}
listSplitter<-function(specieName, ALLspecieList){ #takes specie name and list of specie lists and makes data and metadata object for each specie
cat("\nSplitting list for", specieName,"\n")
dataName<-paste0(specieName, "_data") #B73_data
mdataName<-paste0(specieName, "_metadata") #B73_metadata
specieData<-ALLspecieList[[specieName]][[1]] #Takes B73 list(produced by specieCreator) from MainList, then takes first item in B73 list (belongs to data)
specieMetadata<-ALLspecieList[[specieName]][[2]] #same but 2nd slot in inner list, so metadata
assign(paste0(dataName), t(specieData), envir = .GlobalEnv) #assigns 1rst inner list to the B73_data name, also transposes this dataframe for rows to be genes and samples columns
assign(paste0(mdataName), specieMetadata, envir = .GlobalEnv) #same but 2nd and metadata
cat("Data and metadata dataframes for", specieName, "are done")
return(NULL)
}
tableWriter<-function(specieName,
data=get(paste0(specieName, "_data")), #path, not file name (ex: Wrong: ./data/f.csv; correct: ./data/)
metadata=get(paste0(specieName, "_metadata")),
resultDataPath,
resultMetaPath){ #write the data and metadata tables
resultDataPath<-paste0(resultDataPath, specieName,".csv")
resultMetaPath<-paste0(resultMetaPath, specieName,"_m.txt")
cat("\nWriting", specieName, "data table to:", resultDataPath)
write.table(data, resultDataPath, row.names=TRUE, sep="\t", eol="\n", col.names = NA)
cat("\nWriting", specieName, "metadata table to:", resultMetaPath, "\n")
write.table(metadata, resultMetaPath, row.names=TRUE, sep="\t", eol="\n", col.names = NA)
return (NULL)
}
################################################################################
#### Dataset collection and preparation
#get args from bash
"args = commandArgs(trailingOnly=TRUE)
dataPath<- args[1]
metadataPath<- args[2]
resultDataPath<- args[3]
resultMetaPath<- args[4]
dataNL<-read.delim(dataPath, row.names=1, stringsAsFactors=TRUE)
metadata<-read.delim(metadataPath, header=T, row.names=1, stringsAsFactors=TRUE)"
dataNL<-read.delim("../data/original_data/all5gt.wlen.csv", row.names=1, stringsAsFactors=TRUE)
metadata<-read.delim("../data/original_data/sample.tissue.correct.cluadj.txt", header=T, row.names=1, stringsAsFactors=TRUE)
resultDataPath<-"../"
resultMetaPath<-"../"
colnames(metadata)<-c("specie", "quality", "tissue_abv", "rep", "location")
#If dataNL is data with Length: create a row in metadata named Length as well, so that the 2 datasets can be joined, later we will remove it
if ("Length" %in% colnames(dataNL)){
metadata<-as.data.frame(t(metadata))
metadata$Length<-rep(0, nrow(metadata))
metadata<-as.data.frame(t(metadata))
metadata$specie<-as.factor(metadata$specie)
}
dataNL<-as.data.frame(t(dataNL))
datALL<-merge(dataNL, metadata, by="row.names")
rownames(datALL)<-datALL$Row.names
datALL$Row.names<-NULL
################################################################################
#### Program execution
specieList<-levels(metadata$specie) #get all specie names
#result is B73, a2, etc...
#In the case that its a with length dataset, remove the 0
specieList<-specieList[specieList!=0]
cat("The species are:\n", specieList)
specieResults <- lapply(specieList, function(specieName) specieCreator(datALL, specieName)) #creates a Main list containing each specie list produced by specieCreator
names(specieResults) <- specieList #names the lists according to specie (if not it would be 1,2,3,etc)
View(specieResults)
tmp<-lapply(specieList, function(specieName) listSplitter(specieName, specieResults)) #takes dataframes out of nested list and assigns specie name as variable, samples as columns
View(EP1_data)
b<-as.data.frame(EP1_data)
b<-as.data.frame(t(EP1_data))
View(B73_data)
specieCreator<-function(data_joint, spName){ #selects rows of a dataset based on specie column, then splits between data and metadata
cat("\nSeparating by", spName)
data_specie<-data_joint[data_joint$specie == spName, ] #select rows according to metadata$specie column (now in joint),
#data_specie is now a single specie dataset
#Separate back to data and metadata
cat("\nSplitting data and metadata")
geneCols<-grepl("Zm", names(data_specie)) #all gene columns(data) have Zm, so we search for them
data<-data_specie[, geneCols] #data will be gene columns
metadata<-data_specie[, !geneCols] #metadata will be all that is not gene columns
#Add length to the data if it exists
"Length" %in% rownames(data_joint)
if ("Length" %in% rownames(data_joint)){
lengthTotal<-data_joint["Length",] #take the full length row
lengthData<-lengthTotal[, geneCols] #Take only the columns that are genes from the row
data<-rbind(data, lengthData) #Join the full data only dataframe with the row containing the length
}
cat("\n",spName, "specie table created\n")
return(list(data, metadata))
}
listSplitter<-function(specieName, ALLspecieList){ #takes specie name and list of specie lists and makes data and metadata object for each specie
cat("\nSplitting list for", specieName,"\n")
dataName<-paste0(specieName, "_data") #B73_data
mdataName<-paste0(specieName, "_metadata") #B73_metadata
specieData<-ALLspecieList[[specieName]][[1]] #Takes B73 list(produced by specieCreator) from MainList, then takes first item in B73 list (belongs to data)
specieMetadata<-ALLspecieList[[specieName]][[2]] #same but 2nd slot in inner list, so metadata
assign(paste0(dataName), t(specieData), envir = .GlobalEnv) #assigns 1rst inner list to the B73_data name, also transposes this dataframe for rows to be genes and samples columns
assign(paste0(mdataName), specieMetadata, envir = .GlobalEnv) #same but 2nd and metadata
cat("Data and metadata dataframes for", specieName, "are done")
return(NULL)
}
tableWriter<-function(specieName,
data=get(paste0(specieName, "_data")), #path, not file name (ex: Wrong: ./data/f.csv; correct: ./data/)
metadata=get(paste0(specieName, "_metadata")),
resultDataPath,
resultMetaPath){ #write the data and metadata tables
resultDataPath<-paste0(resultDataPath, specieName,".csv")
resultMetaPath<-paste0(resultMetaPath, specieName,"_m.txt")
cat("\nWriting", specieName, "data table to:", resultDataPath)
write.table(data, resultDataPath, row.names=TRUE, sep="\t", eol="\n", col.names = NA)
cat("\nWriting", specieName, "metadata table to:", resultMetaPath, "\n")
write.table(metadata, resultMetaPath, row.names=TRUE, sep="\t", eol="\n", col.names = NA)
return (NULL)
}
################################################################################
#### Dataset collection and preparation
#get args from bash
"args = commandArgs(trailingOnly=TRUE)
dataPath<- args[1]
metadataPath<- args[2]
resultDataPath<- args[3]
resultMetaPath<- args[4]
dataNL<-read.delim(dataPath, row.names=1, stringsAsFactors=TRUE)
metadata<-read.delim(metadataPath, header=T, row.names=1, stringsAsFactors=TRUE)"
dataNL<-read.delim("../data/original_data/all5gt.wlen.csv", row.names=1, stringsAsFactors=TRUE)
metadata<-read.delim("../data/original_data/sample.tissue.correct.cluadj.txt", header=T, row.names=1, stringsAsFactors=TRUE)
resultDataPath<-"../"
resultMetaPath<-"../"
colnames(metadata)<-c("specie", "quality", "tissue_abv", "rep", "location")
#If dataNL is data with Length: create a row in metadata named Length as well, so that the 2 datasets can be joined, later we will remove it
if ("Length" %in% colnames(dataNL)){
metadata<-as.data.frame(t(metadata))
metadata$Length<-rep(0, nrow(metadata))
metadata<-as.data.frame(t(metadata))
metadata$specie<-as.factor(metadata$specie)
}
dataNL<-as.data.frame(t(dataNL))
datALL<-merge(dataNL, metadata, by="row.names")
rownames(datALL)<-datALL$Row.names
datALL$Row.names<-NULL
################################################################################
#### Program execution
specieList<-levels(metadata$specie) #get all specie names
#result is B73, a2, etc...
#In the case that its a with length dataset, remove the 0
specieList<-specieList[specieList!=0]
cat("The species are:\n", specieList)
specieResults <- lapply(specieList, function(specieName) specieCreator(datALL, specieName)) #creates a Main list containing each specie list produced by specieCreator
specieCreator<-function(data_joint, spName){ #selects rows of a dataset based on specie column, then splits between data and metadata
cat("\nSeparating by", spName)
data_specie<-data_joint[data_joint$specie == spName, ] #select rows according to metadata$specie column (now in joint),
#data_specie is now a single specie dataset
#Separate back to data and metadata
cat("\nSplitting data and metadata")
geneCols<-grepl("Zm", names(data_specie)) #all gene columns(data) have Zm, so we search for them
data<-data_specie[, geneCols] #data will be gene columns
metadata<-data_specie[, !geneCols] #metadata will be all that is not gene columns
#Add length to the data if it exists
print("Length" %in% rownames(data_joint))
if ("Length" %in% rownames(data_joint)){
lengthTotal<-data_joint["Length",] #take the full length row
lengthData<-lengthTotal[, geneCols] #Take only the columns that are genes from the row
data<-rbind(data, lengthData) #Join the full data only dataframe with the row containing the length
}
cat("\n",spName, "specie table created\n")
return(list(data, metadata))
}
dataNL<-read.delim("../data/original_data/all5gt.wlen.csv", row.names=1, stringsAsFactors=TRUE)
metadata<-read.delim("../data/original_data/sample.tissue.correct.cluadj.txt", header=T, row.names=1, stringsAsFactors=TRUE)
resultDataPath<-"../"
resultMetaPath<-"../"
colnames(metadata)<-c("specie", "quality", "tissue_abv", "rep", "location")
#If dataNL is data with Length: create a row in metadata named Length as well, so that the 2 datasets can be joined, later we will remove it
if ("Length" %in% colnames(dataNL)){
metadata<-as.data.frame(t(metadata))
metadata$Length<-rep(0, nrow(metadata))
metadata<-as.data.frame(t(metadata))
metadata$specie<-as.factor(metadata$specie)
}
dataNL<-as.data.frame(t(dataNL))
datALL<-merge(dataNL, metadata, by="row.names")
rownames(datALL)<-datALL$Row.names
datALL$Row.names<-NULL
specieList<-levels(metadata$specie) #get all specie names
#In the case that its a with length dataset, remove the 0
specieList<-specieList[specieList!=0]
cat("The species are:\n", specieList)
specieResults <- lapply(specieList, function(specieName) specieCreator(datALL, specieName)) #creates a Main list containing each specie list produced by specieCreator
specieCreator<-function(data_joint, spName){ #selects rows of a dataset based on specie column, then splits between data and metadata
cat("\nSeparating by", spName)
data_specie<-data_joint[data_joint$specie == spName, ] #select rows according to metadata$specie column (now in joint),
#data_specie is now a single specie dataset
#Separate back to data and metadata
cat("\nSplitting data and metadata")
geneCols<-grepl("Zm", names(data_specie)) #all gene columns(data) have Zm, so we search for them
data<-data_specie[, geneCols] #data will be gene columns
metadata<-data_specie[, !geneCols] #metadata will be all that is not gene columns
#Add length to the data if it exists
if ("Length" %in% rownames(data_joint)){
lengthTotal<-data_joint["Length",] #take the full length row
lengthData<-lengthTotal[, geneCols] #Take only the columns that are genes from the row
data<-rbind(data, lengthData) #Join the full data only dataframe with the row containing the length
data["Length",]
}
cat("\n",spName, "specie table created\n")
return(list(data, metadata))
}
dataNL<-read.delim("../data/original_data/all5gt.wlen.csv", row.names=1, stringsAsFactors=TRUE)
metadata<-read.delim("../data/original_data/sample.tissue.correct.cluadj.txt", header=T, row.names=1, stringsAsFactors=TRUE)
resultDataPath<-"../"
resultMetaPath<-"../"
colnames(metadata)<-c("specie", "quality", "tissue_abv", "rep", "location")
#If dataNL is data with Length: create a row in metadata named Length as well, so that the 2 datasets can be joined, later we will remove it
if ("Length" %in% colnames(dataNL)){
metadata<-as.data.frame(t(metadata))
metadata$Length<-rep(0, nrow(metadata))
metadata<-as.data.frame(t(metadata))
metadata$specie<-as.factor(metadata$specie)
}
dataNL<-as.data.frame(t(dataNL))
datALL<-merge(dataNL, metadata, by="row.names")
rownames(datALL)<-datALL$Row.names
datALL$Row.names<-NULL
################################################################################
#### Program execution
specieList<-levels(metadata$specie) #get all specie names
#result is B73, a2, etc...
#In the case that its a with length dataset, remove the 0
specieList<-specieList[specieList!=0]
cat("The species are:\n", specieList)
specieResults <- lapply(specieList, function(specieName) specieCreator(datALL, specieName)) #creates a Main list containing each specie list produced by specieCreator
specieCreator<-function(data_joint, spName){ #selects rows of a dataset based on specie column, then splits between data and metadata
cat("\nSeparating by", spName)
data_specie<-data_joint[data_joint$specie == spName, ] #select rows according to metadata$specie column (now in joint),
#data_specie is now a single specie dataset
#Separate back to data and metadata
cat("\nSplitting data and metadata")
geneCols<-grepl("Zm", names(data_specie)) #all gene columns(data) have Zm, so we search for them
data<-data_specie[, geneCols] #data will be gene columns
metadata<-data_specie[, !geneCols] #metadata will be all that is not gene columns
#Add length to the data if it exists
if ("Length" %in% rownames(data_joint)){
lengthTotal<-data_joint["Length",] #take the full length row
lengthData<-lengthTotal[, geneCols] #Take only the columns that are genes from the row
data<-rbind(data, lengthData) #Join the full data only dataframe with the row containing the length
print(data["Length",])
}
cat("\n",spName, "specie table created\n")
return(list(data, metadata))
}
specieResults <- lapply(specieList, function(specieName) specieCreator(datALL, specieName)) #creates a Main list containing each specie list produced by specieCreator
specieCreator<-function(data_joint, spName){ #selects rows of a dataset based on specie column, then splits between data and metadata
cat("\nSeparating by", spName)
data_specie<-data_joint[data_joint$specie == spName, ] #select rows according to metadata$specie column (now in joint),
#data_specie is now a single specie dataset
#Separate back to data and metadata
cat("\nSplitting data and metadata")
geneCols<-grepl("Zm", names(data_specie)) #all gene columns(data) have Zm, so we search for them
data<-data_specie[, geneCols] #data will be gene columns
metadata<-data_specie[, !geneCols] #metadata will be all that is not gene columns
#Add length to the data if it exists
if ("Length" %in% rownames(data_joint)){
lengthTotal<-data_joint["Length",] #take the full length row
lengthData<-lengthTotal[, geneCols] #Take only the columns that are genes from the row
data<-rbind(data, lengthData) #Join the full data only dataframe with the row containing the length
tail(data["Length",])
}
cat("\n",spName, "specie table created\n")
return(list(data, metadata))
}
specieResults <- lapply(specieList, function(specieName) specieCreator(datALL, specieName)) #creates a Main list containing each specie list produced by specieCreator
names(specieResults) <- specieList #names the lists according to specie (if not it would be 1,2,3,etc)
specieCreator<-function(data_joint, spName){ #selects rows of a dataset based on specie column, then splits between data and metadata
cat("\nSeparating by", spName)
data_specie<-data_joint[data_joint$specie == spName, ] #select rows according to metadata$specie column (now in joint),
#data_specie is now a single specie dataset
#Separate back to data and metadata
cat("\nSplitting data and metadata")
geneCols<-grepl("Zm", names(data_specie)) #all gene columns(data) have Zm, so we search for them
data<-data_specie[, geneCols] #data will be gene columns
metadata<-data_specie[, !geneCols] #metadata will be all that is not gene columns
#Add length to the data if it exists
if ("Length" %in% rownames(data_joint)){
lengthTotal<-data_joint["Length",] #take the full length row
lengthData<-lengthTotal[, geneCols] #Take only the columns that are genes from the row
data<-rbind(data, lengthData) #Join the full data only dataframe with the row containing the length
print(rownames(data))
}
cat("\n",spName, "specie table created\n")
return(list(data, metadata))
}
specieResults <- lapply(specieList, function(specieName) specieCreator(datALL, specieName)) #creates a Main list containing each specie list produced by specieCreator
names(specieResults) <- specieList #names the lists according to specie (if not it would be 1,2,3,etc)
tmp<-lapply(specieList, function(specieName) listSplitter(specieName, specieResults)) #takes dataframes out of nested list and assigns specie name as variable, samples as columns
View(PE75_data)
colnames(PE75_data)
PE75_data$Length
listRows<-sapply(specieResults, function(specieSublist) nrow(specieSublist[[1]])) #get number of rows of each specie, and put them on a vector
cat("\n\nNumber of rows of original dataframe:", nrow(datALL))
cat("\nTotal rows of all resulting databases combined:", sum(listRows), "\n")
dataNL<-read.delim("../data/original_data/all5gt.noen.csv", row.names=1, stringsAsFactors=TRUE)
dataNL<-read.delim("../data/original_data/all5gt.nolen.csv", row.names=1, stringsAsFactors=TRUE)
metadata<-read.delim("../data/original_data/sample.tissue.correct.cluadj.txt", header=T, row.names=1, stringsAsFactors=TRUE)
resultDataPath<-"../"
resultMetaPath<-"../"
colnames(metadata)<-c("specie", "quality", "tissue_abv", "rep", "location")
"Length" %in% colnames(dataNL)
#If dataNL is data with Length: create a row in metadata named Length as well, so that the 2 datasets can be joined, later we will remove it
if ("Length" %in% colnames(dataNL)){
metadata<-as.data.frame(t(metadata))
metadata$Length<-rep(0, nrow(metadata))
metadata<-as.data.frame(t(metadata))
metadata$specie<-as.factor(metadata$specie)
}
dataNL<-as.data.frame(t(dataNL))
datALL<-merge(dataNL, metadata, by="row.names")
rownames(datALL)<-datALL$Row.names
datALL$Row.names<-NULL
specieList<-levels(metadata$specie) #get all specie names
cat("The species are:\n", specieList)
#In the case that its a with length dataset, remove the 0
specieList<-specieList[specieList!=0]
cat("The species are:\n", specieList)
specieResults <- lapply(specieList, function(specieName) specieCreator(datALL, specieName)) #creates a Main list containing each specie list produced by specieCreator
colnames(PE75_data)
#### Functions
specieCreator<-function(data_joint, spName){ #selects rows of a dataset based on specie column, then splits between data and metadata
cat("\nSeparating by", spName)
data_specie<-data_joint[data_joint$specie == spName, ] #select rows according to metadata$specie column (now in joint),
#data_specie is now a single specie dataset
#Separate back to data and metadata
cat("\nSplitting data and metadata")
geneCols<-grepl("Zm", names(data_specie)) #all gene columns(data) have Zm, so we search for them
data<-data_specie[, geneCols] #data will be gene columns
metadata<-data_specie[, !geneCols] #metadata will be all that is not gene columns
print("Length" %in% rownames(data_joint))
#Add length to the data if it exists
if ("Length" %in% rownames(data_joint)){
lengthTotal<-data_joint["Length",] #take the full length row
lengthData<-lengthTotal[, geneCols] #Take only the columns that are genes from the row
data<-rbind(data, lengthData) #Join the full data only dataframe with the row containing the length
}
cat("\n",spName, "specie table created\n")
return(list(data, metadata))
}
listSplitter<-function(specieName, ALLspecieList){ #takes specie name and list of specie lists and makes data and metadata object for each specie
cat("\nSplitting list for", specieName,"\n")
dataName<-paste0(specieName, "_data") #B73_data
mdataName<-paste0(specieName, "_metadata") #B73_metadata
specieData<-ALLspecieList[[specieName]][[1]] #Takes B73 list(produced by specieCreator) from MainList, then takes first item in B73 list (belongs to data)
specieMetadata<-ALLspecieList[[specieName]][[2]] #same but 2nd slot in inner list, so metadata
assign(paste0(dataName), t(specieData), envir = .GlobalEnv) #assigns 1rst inner list to the B73_data name, also transposes this dataframe for rows to be genes and samples columns
assign(paste0(mdataName), specieMetadata, envir = .GlobalEnv) #same but 2nd and metadata
cat("Data and metadata dataframes for", specieName, "are done")
return(NULL)
}
tableWriter<-function(specieName,
data=get(paste0(specieName, "_data")), #path, not file name (ex: Wrong: ./data/f.csv; correct: ./data/)
metadata=get(paste0(specieName, "_metadata")),
resultDataPath,
resultMetaPath){ #write the data and metadata tables
resultDataPath<-paste0(resultDataPath, specieName,".csv")
resultMetaPath<-paste0(resultMetaPath, specieName,"_m.txt")
cat("\nWriting", specieName, "data table to:", resultDataPath)
write.table(data, resultDataPath, row.names=TRUE, sep="\t", eol="\n", col.names = NA)
cat("\nWriting", specieName, "metadata table to:", resultMetaPath, "\n")
write.table(metadata, resultMetaPath, row.names=TRUE, sep="\t", eol="\n", col.names = NA)
return (NULL)
}
################################################################################
#### Dataset collection and preparation
#get args from bash
"args = commandArgs(trailingOnly=TRUE)
dataPath<- args[1]
metadataPath<- args[2]
resultDataPath<- args[3]
resultMetaPath<- args[4]
dataNL<-read.delim(dataPath, row.names=1, stringsAsFactors=TRUE)
metadata<-read.delim(metadataPath, header=T, row.names=1, stringsAsFactors=TRUE)"
dataNL<-read.delim("../data/original_data/all5gt.nolen.csv", row.names=1, stringsAsFactors=TRUE)
metadata<-read.delim("../data/original_data/sample.tissue.correct.cluadj.txt", header=T, row.names=1, stringsAsFactors=TRUE)
resultDataPath<-"../"
resultMetaPath<-"../"
colnames(metadata)<-c("specie", "quality", "tissue_abv", "rep", "location")
#If dataNL is data with Length: create a row in metadata named Length as well, so that the 2 datasets can be joined, later we will remove it
if ("Length" %in% colnames(dataNL)){
metadata<-as.data.frame(t(metadata))
metadata$Length<-rep(0, nrow(metadata))
metadata<-as.data.frame(t(metadata))
metadata$specie<-as.factor(metadata$specie)
}
dataNL<-as.data.frame(t(dataNL))
datALL<-merge(dataNL, metadata, by="row.names")
rownames(datALL)<-datALL$Row.names
datALL$Row.names<-NULL
################################################################################
#### Program execution
specieList<-levels(metadata$specie) #get all specie names
#In the case that its a with length dataset, remove the 0
specieList<-specieList[specieList!=0]
cat("The species are:\n", specieList)
dataNL<-read.delim("../data/original_data/all5gt.nolen.csv", row.names=1, stringsAsFactors=TRUE)
metadata<-read.delim("../data/original_data/sample.tissue.correct.cluadj.txt", header=T, row.names=1, stringsAsFactors=TRUE)
resultDataPath<-"../"
resultMetaPath<-"../"
colnames(metadata)<-c("specie", "quality", "tissue_abv", "rep", "location")
#If dataNL is data with Length: create a row in metadata named Length as well, so that the 2 datasets can be joined, later we will remove it
if ("Length" %in% colnames(dataNL)){
metadata<-as.data.frame(t(metadata))
metadata$Length<-rep(0, nrow(metadata))
metadata<-as.data.frame(t(metadata))
metadata$specie<-as.factor(metadata$specie)
}
dataNL<-as.data.frame(t(dataNL))
datALL<-merge(dataNL, metadata, by="row.names")
rownames(datALL)<-datALL$Row.names
datALL$Row.names<-NULL
specieList<-levels(metadata$specie) #get all specie names
cat("The species are:\n", specieList)
#In the case that its a with length dataset, remove the 0
specieList<-specieList[specieList!=0]
specieResults <- lapply(specieList, function(specieName) specieCreator(datALL, specieName)) #creates a Main list containing each specie list produced by specieCreator
names(specieResults) <- specieList #names the lists according to specie (if not it would be 1,2,3,etc)
tmp<-lapply(specieList, function(specieName) listSplitter(specieName, specieResults)) #takes dataframes out of nested list and assigns specie name as variable, samples as columns
colnames(B73_data)
colnames(PE75_data)
listRows<-sapply(specieResults, function(specieSublist) nrow(specieSublist[[1]])) #get number of rows of each specie, and put them on a vector
cat("\n\nNumber of rows of original dataframe:", nrow(datALL))
cat("\nTotal rows of all resulting databases combined:", sum(listRows), "\n")
tmp<-lapply(specieList, function(specieName) tableWriter(specieName, resultDataPath=resultDataPath, resultMetaPath=resultMetaPath))
dataNL<-read.delim("../data/wlen/B73.csv", row.names=1, stringsAsFactors=TRUE)
dataNL<-read.delim("../data/wlen/B73.csv", row.names=1, stringsAsFactors=TRUE)
View(dataNL)
dataPath<-"./../data/original_data/all5gt.wlen.csv"
metadataPath"./../data/original_data/sample.tissue.correct.cluadj.txt"
data<-read.delim(dataPath, row.names=1, stringsAsFactors=TRUE)
metadata<-read.delim(metadataPath, header=FALSE, row.names=1, stringsAsFactors=TRUE)
metadataPath<-"./../data/original_data/sample.tissue.correct.cluadj.txt"
data<-read.delim(dataPath, row.names=1, stringsAsFactors=TRUE)
metadata<-read.delim(metadataPath, header=FALSE, row.names=1, stringsAsFactors=TRUE)
"Length" %in% colnames(data)
metadata<-as.data.frame(t(metadata))
metadata$Length<-rep(0, nrow(metadata))
metadata<-as.data.frame(t(metadata))
metadata$specie<-as.factor(metadata$specie)
View(metadata)
#data matcher function
dataMatcher<-function(data, metadata){
options(warn=-1)
cat("Data begins with:" , dim(data))
cat("\nMetadata begins with:", dim(metadata))
#Match data to metadata
data <- data[, order(colnames(data))]
metadata <- metadata[order(rownames(metadata)), ]
cat("\nColumns data = Rows of metatdata?", all(rownames(metadata) == colnames(data)))
#If TRUE, columns of data and rows of metadata are matched
cat("\nRemove the excess from data")
data<-data[,colnames(data) %in% rownames(metadata)] #remove data not present in metadata
cat("\nData end with:" , dim(data))
cat("\nRemove the excess from metadata")
metadata<-metadata[rownames(metadata) %in% colnames(data),] #remove metadata not present in data
cat("\nMetadata end with:" , dim(metadata), "\n")
options(warn=0)
return(list(data, metadata))
}
jointData<-dataMatcher(data, metadata)
dataNL<-read.delim("../data/wlen/B73.csv", row.names=1, stringsAsFactors=TRUE)
View(dataNL)
dataNL$Length
