TopSig$TotalCounts<-TopSig$ModuleCounts<-TopSig$Relevancy<-TopSig$TopSig<-NULL
TopSig$Pvalue<-as.numeric(formatC(TopSig$Pvalue, format="e", digits=2))
ggplot(TopSig, aes(x=Function, y=Module, color=Pvalue, size=Pvalue))+
geom_point()+
scale_color_continuous(trans="reverse")+#, breaks=c(min(TopSig$Pvalue)))+
scale_size(range = c(0, 5), trans="reverse")+
labs(size="P-value", color="P-value")+
theme_bw()+
theme(axis.text.x=element_text(angle=45, hjust=1, size=10),
axis.text.y=element_text(size=10),
legend.key.width=unit(1, "cm"),
legend.text=element_text(size=12),
legend.title=element_text(size=16),
plot.background=element_rect(fill="transparent",color="transparent"),
panel.border=element_rect(linewidth=1),
panel.grid.major=element_line(color="grey"),
axis.ticks=element_line(colour="black"),
axis.ticks.length = unit(8, "pt"))+
guides(color=guide_legend(order=1),
size=guide_legend(order=1))
TopSig$Pvalue==0
?formatC
formatC(TopSig$Pvalue, digits=2)
#Set up table for significant functions in each module, remove unneeded data
TopSig<-as.data.frame(subset(pvdata, TopSig))
TopSig$TotalCounts<-TopSig$ModuleCounts<-TopSig$Relevancy<-TopSig$TopSig<-NULL
TopSig$Pvalue
as.numeric(formatC(TopSig$Pvalue, digits=2))
formatC(TopSig$Pvalue, format="f", digits=2)
TopSig$Pvalue, format="d", digits=2)
formatC(TopSig$Pvalue, format="d", digits=2)
formatC(TopSig$Pvalue, digits=2)
formatC(TopSig$Pvalue, digits=2, mode="double")
formatC(TopSig$Pvalue, digits=2, format="g")
as.numeric(formatC(TopSig$Pvalue, digits=2, format="g"))
formatC(TopSig$Pvalue, digits=2, format="g", mode="double")
as.numeric(formatC(TopSig$Pvalue, digits=2, format="g", mode="double"))
TopSig$Pvalue
formatC(TopSig$Pvalue, digits=2, format="G")
as.numeric(formatC(TopSig$Pvalue, digits=2, format="G"))
formatC(TopSig$Pvalue, digits=2, format="fg")
TopSig$Pvalue
formatC(TopSig$Pvalue, digits=2)
as.numeric(formatC(TopSig$Pvalue, digits=2))
#Plots significance per function in each module, highlights most significant in total and writes them in a table
#Step 3
library(ggplot2)
library(plotly)
library(ggnewscale)
#read data
dChoice<-"anT_mercator" #anT_mercator, anT_prot-scriber, anT_swissprot
dChoice<-"d_1"
pvdata<-read.table(paste0("../modules/Pres/", dChoice, "_sheet.txt"), sep='\t', header=TRUE)
#Choose relevant
pvdata$Relevancy<-as.logical(pvdata$Relevancy)
pvdata<-pvdata[pvdata$Relevancy,]
#Get top x significant values
highSig<-sort(pvdata$Pvalue)[1:10]
pvdata$TopSig<-pvdata$Pvalue %in% highSig
#plot all values
bareplot<-ggplot(pvdata, aes(x=Function, y=Module))+
geom_point(aes(size=Pvalue, color=Pvalue))+
scale_size(range = c(0, 5), trans="reverse")+
scale_color_continuous(trans="reverse")+
labs(size="P-value", color="P-value")+
theme_bw()+
theme(axis.text.x=element_text(angle=45, hjust=1, size=10),
axis.text.y=element_text(size=10),
legend.key.width=unit(1, "cm"),
legend.text=element_text(size=12),
legend.title=element_text(size=16),
plot.background=element_rect(fill="transparent",color="transparent"),
panel.border=element_rect(linewidth=1),
panel.grid.major=element_line(color="grey"),
axis.ticks=element_line(colour="black"),
axis.ticks.length = unit(8, "pt"))+
guides(color=guide_legend(order=1),
size=guide_legend(order=1))
#highlight significant values(all equal)
hplot<-bareplot+
geom_point(data=subset(pvdata, TopSig), aes(fill=TopSig), color="darkorange", size=7)+
labs(fill="")+scale_fill_hue(labels=c("Highly\nsignificant"))+
guides(fill=guide_legend(order=2))+
theme(legend.text=element_text(size=14))
png(paste0("../modules/SigPlots/sig_", dChoice, ".png"), width=1600, height=800)
hplot#+ggtitle(dChoice)
dev.off()
svg(paste0("../modules/SigPlots/sig_", dChoice, ".svg"), width=1600/60, height=800/60)
hplot#+ggtitle(dChoice)
dev.off()
#ggplotly(hplot)
#Set up table for significant functions in each module, remove unneeded data
TopSig<-as.data.frame(subset(pvdata, TopSig))
TopSig$TotalCounts<-TopSig$ModuleCounts<-TopSig$Relevancy<-TopSig$TopSig<-NULL
TopSig$Pvalue<-as.numeric(formatC(TopSig$Pvalue, digits=2))
TopPlot<-ggplot(TopSig, aes(x=Function, y=Module, color=Pvalue, size=Pvalue))+
geom_point()+
scale_color_continuous(trans="reverse")+#, breaks=c(min(TopSig$Pvalue)))+
scale_size(range = c(0, 5), trans="reverse")+
labs(size="P-value", color="P-value")+
theme_bw()+
theme(axis.text.x=element_text(angle=45, hjust=1, size=10),
axis.text.y=element_text(size=10),
legend.key.width=unit(1, "cm"),
legend.text=element_text(size=12),
legend.title=element_text(size=16),
plot.background=element_rect(fill="transparent",color="transparent"),
panel.border=element_rect(linewidth=1),
panel.grid.major=element_line(color="grey"),
axis.ticks=element_line(colour="black"),
axis.ticks.length = unit(8, "pt"))+
guides(color=guide_legend(order=1),
size=guide_legend(order=1))
png(paste0("../modules/SigPlots/top/top_", dChoice, ".png"), width=1600, height=800)
TopPlot#+ggtitle(dChoice)
dev.off()
svg(paste0("../modules/SigPlots/top/top_", dChoice, ".svg"), width=1600/60, height=800/60)
TopPlot#+ggtitle(dChoice)
dev.off()
#write top significant to table
write.table(TopSig, paste0("../modules/SigPlots/top/top_", dChoice, ".txt"), sep='\t', row.names=FALSE)
ggplot(TopSig, aes(x=Function, y=Module, color=Pvalue, size=Pvalue))+
geom_point()+
scale_color_continuous(trans="reverse")+#, breaks=c(min(TopSig$Pvalue)))+
scale_size(range = c(0, 10), trans="reverse")+
labs(size="P-value", color="P-value")+
theme_bw()+
theme(axis.text.x=element_text(angle=45, hjust=1, size=10),
axis.text.y=element_text(size=10),
legend.key.width=unit(1, "cm"),
legend.text=element_text(size=12),
legend.title=element_text(size=16),
plot.background=element_rect(fill="transparent",color="transparent"),
panel.border=element_rect(linewidth=1),
panel.grid.major=element_line(color="grey"),
axis.ticks=element_line(colour="black"),
axis.ticks.length = unit(8, "pt"))+
guides(color=guide_legend(order=1),
size=guide_legend(order=1))
ggplot(TopSig, aes(x=Function, y=Module, color=Pvalue, size=Pvalue))+
geom_point()+
scale_color_continuous(trans="reverse")+#, breaks=c(min(TopSig$Pvalue)))+
scale_size(range = c(0, 7), trans="reverse")+
labs(size="P-value", color="P-value")+
theme_bw()+
theme(axis.text.x=element_text(angle=45, hjust=1, size=10),
axis.text.y=element_text(size=10),
legend.key.width=unit(1, "cm"),
legend.text=element_text(size=12),
legend.title=element_text(size=16),
plot.background=element_rect(fill="transparent",color="transparent"),
panel.border=element_rect(linewidth=1),
panel.grid.major=element_line(color="grey"),
axis.ticks=element_line(colour="black"),
axis.ticks.length = unit(8, "pt"))+
guides(color=guide_legend(order=1),
size=guide_legend(order=1))
TopPlot<-ggplot(TopSig, aes(x=Function, y=Module, color=Pvalue, size=Pvalue))+
geom_point()+
scale_color_continuous(trans="reverse")+#, breaks=c(min(TopSig$Pvalue)))+
scale_size(range = c(0, 7), trans="reverse")+
labs(size="P-value", color="P-value")+
theme_bw()+
theme(axis.text.x=element_text(angle=45, hjust=1, size=10),
axis.text.y=element_text(size=10),
legend.key.width=unit(1, "cm"),
legend.text=element_text(size=12),
legend.title=element_text(size=16),
plot.background=element_rect(fill="transparent",color="transparent"),
panel.border=element_rect(linewidth=1),
panel.grid.major=element_line(color="grey"),
axis.ticks=element_line(colour="black"),
axis.ticks.length = unit(8, "pt"))+
guides(color=guide_legend(order=1),
size=guide_legend(order=1))
png(paste0("../modules/SigPlots/top/top_", dChoice, ".png"), width=1600, height=800)
TopPlot#+ggtitle(dChoice)
dev.off()
svg(paste0("../modules/SigPlots/top/top_", dChoice, ".svg"), width=1600/60, height=800/60)
TopPlot#+ggtitle(dChoice)
dev.off()
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, fig.width=16, fig.height=8)
knitr::opts_chunk$set(purl = TRUE)
library(WGCNA)
allowWGCNAThreads()
library(randomcoloR)
library(edgeR)
library(tidyverse)
library(dplyr)
library(grid)
library(gridExtra)
#devtools::install_github("kevinblighe/CorLevelPlot")
library(CorLevelPlot)
library(ggpubr)
library(plotly)
library(factoextra)
library(umap)
library(heatmaply)
dataPath<-paste0("../data/wlen/data_wlen.csv")
metadataPath<-paste0("../data/metadata.txt")
dataNL<-read.delim(dataPath, row.names=1, stringsAsFactors=TRUE)
setwd("~/Desktop/Intership/work/coexpression_code")
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, fig.width=16, fig.height=8)
knitr::opts_chunk$set(purl = TRUE)
library(WGCNA)
allowWGCNAThreads()
library(randomcoloR)
library(edgeR)
library(tidyverse)
library(dplyr)
library(grid)
library(gridExtra)
#devtools::install_github("kevinblighe/CorLevelPlot")
library(CorLevelPlot)
library(ggpubr)
library(plotly)
library(factoextra)
library(umap)
library(heatmaply)
dataPath<-paste0("../data/wlen/data_wlen.csv")
metadataPath<-paste0("../data/metadata.txt")
dataNL<-read.delim(dataPath, row.names=1, stringsAsFactors=TRUE)
metadata<-read.delim(metadataPath, header=T, row.names=1, stringsAsFactors=TRUE)
colnames(metadata)<-c("specie", "quality", "tissue_abv", "rep", "location")
if ("Length" %in% colnames(dataNL)){
length_vec<-dataNL$Length
}
dim(dataNL)
dim(metadata)
dataMatcher<-function(data, metadata){
options(warn=-1)
cat("Data begins with:" , dim(data))
cat("\nMetadata begins with:", dim(metadata))
#Match data to metadata
data <- data[, order(colnames(data))]
metadata <- metadata[order(rownames(metadata)), ]
cat("\nColumns data = Rows of metatdata?", all(rownames(metadata) == colnames(data)))
#If TRUE, columns of data and rows of metadata are matched
cat("\nRemove the excess from data")
data<-data[,colnames(data) %in% rownames(metadata)] #remove data not present in metadata
cat("\nData end with:" , dim(data))
cat("\nRemove the excess from metadata")
metadata<-metadata[rownames(metadata) %in% colnames(data),] #remove metadata not present in data
cat("\nMetadata end with:" , dim(metadata), "\n")
options(warn=0)
return(list(data, metadata))
}
jointData<-dataMatcher(dataNL, metadata)
dataNL<-jointData[[1]]
metadata<-jointData[[2]]
#Should be all 0 due to preprocessing filtering
levels(as.factor(metadata$quality))
#Mapped abbreviations
levels(metadata$tissue_abv)
#reps 1,2,3 and 4, is there an imbalance?
table(metadata$rep)
levels(metadata$location)
#Different total amounts of each tissue replicate would indicate that one of the species does not present the same amount copies
table(metadata$location)
#there are different total numbers of tissue replicates
#Solve it by using 1 replicate per tissue (mean of existing replicates)
outDetect<-goodSamplesGenes(t(dataNL))
table(outDetect$goodGenes) #False genes are outliers
table(outDetect$goodSamples) #All samples are True = no outliers
dataNL<-dataNL[outDetect$goodGenes==TRUE,] #remove ouliers
if (exists("length_vec")){ #only if it exists
length_vec<-length_vec[outDetect$goodGenes==TRUE] #if length_vec exists remove outliers from there as well
}
#add the name of the species to the replicate, to be able to differentiate it
#save location
metadata$org_location<-as.factor(metadata$location)
#create specialized location
metadata$location<-paste(metadata$specie, metadata$location, sep="_")
metadata$location<-as.factor(metadata$location)
rsumer<-function(data, metadata, tissue_name){ #calculates the mean of all columns that belong to a location (ex: mean of all COB columns)
loc_mdata<-metadata[metadata$location == tissue_name, ] #filter metadata tissue (get metadata of location only)
data<-data[,colnames(data) %in% rownames(loc_mdata)] #get data of location only, based on metadata
if (1<ncol(data.frame(data))){ #If there's only 1 replicate, don't try to do the mean (it gives error)
data<-rowMeans(data) #calculate mean for each gene out of the locations(replicates)
}
return(as.data.frame(data))
}
tissue_data<-levels(metadata$location) #get list of tissue names
d_joint<-sapply(tissue_data, function(tissue_name) rsumer(dataNL, metadata, tissue_name)) #returns an array where each entry is a column with the mean data of the replicates (rows are genes)
repl_data<-as.data.frame(d_joint) #data joint by replicate
colnames(repl_data) = gsub(pattern = "*.data", replacement = "", x = tolower(colnames(repl_data))) #get column names to be only location
rownames(repl_data)<-rownames(dataNL) #rename rows to be genes again
#Create a column for the location+species
repl_meta<-as.data.frame(colnames(repl_data))
colnames(repl_meta)<-c("location")
#Split the created column and add 2 columns to repl_meta, one for the species and one for the tissue
temp_meta<-data.frame(t(data.frame(strsplit(as.character(repl_meta$location), "_"))))
repl_meta<-data.frame(repl_meta$location, temp_meta$X1, temp_meta$X2)
colnames(repl_meta)<-c("location", "species", "org_location")
multiColHist<-function(data, location, color_var){ #gets the data table, the concrete column(tissue) and the color for the tissue
loc_var<-data[[location]] #get the tissue data
p<-ggplot(data, aes(x=loc_var))+
geom_histogram(bins= 30, fill=color_var, color="black")+
xlab("")+ylab("")+theme_minimal() #plot a colored histogram for all genes of X tissue
return(p)
}
#Create a vector to select 2 examples of each line
repl_selection<-seq(1,ncol(repl_data), by=round(ncol(repl_data)/10))
colorList<-distinctColorPalette(length(repl_selection)) #make a list with a color for each tissue
#Create a legend that realates each color to a tissue
#use the repl_meta dataframe for creating the plot, as it contains all tissue(location) names
legend_plot<-ggplot(repl_meta[repl_selection,], aes(x=1, y=location, color=location))+
geom_point()+
scale_color_manual(values=colorList)+
guides(color=guide_legend(ncol=1))+
theme_void()+labs(color="Tissue")+
theme(legend.title=element_text(size=18),
legend.text=element_text(size=15)) #plot used only to get the legend that associates colors with localizations(tissues)
legend_var<-get_legend(legend_plot) #place the legend into a variable
RawHistList<-list() #to store the plots
for (i in 1:nrow(repl_meta[repl_selection,])){
color_var<-colorList[i]
loc<-colnames(repl_data)[i]
temp_plot<-multiColHist(repl_data, loc, color_var)
RawHistList[[i]]<-temp_plot
} #iterates over each tissue, creates a plot with a distinct color for it and stores it in a list
plotTitle<-paste0("Raw data distribution")
raw_Ptab<-arrangeGrob(grobs=RawHistList, ncol=ceiling(nrow(repl_meta[repl_selection,])/6)) #creates a table that organizes the plots
#png("./DistrPlots/Raw_distPlot.png", width=1600, height=800) #Raw_distPlot.png
grid.arrange(raw_Ptab, legend_var, widths = c(10, 2.3), ncol=2, top=textGrob(plotTitle, gp=gpar(fontsize=20))) #plots the plot list and legend together
#dev.off()
#edgeR object
dge<-DGEList(repl_data)
#Calculate normalization factors
dge<-calcNormFactors(dge)
#Get normalized counts
Nrepl_data<-cpm(dge, log=TRUE)
NormType<-"CPM"
#Filter low expression genes
keep<-apply(Nrepl_data, 1, max)>=0 #keep genes where the counts for at least one replicate are of at least 1 (0 because of log)
Nrepl_data<-Nrepl_data[keep,]
#Nrepl to data frame
Nrepl_data<-as.data.frame(Nrepl_data) #eventually transpose
NormHistList<-list() #to store the plots
for (i in 1:nrow(repl_meta[repl_selection,])){
color_var<-colorList[i]
loc<-colnames(repl_data)[i]
temp_plot<-multiColHist(Nrepl_data, loc, color_var)
NormHistList[[i]]<-temp_plot
} #iterates over each tissue, creates a plot with a distinct color for it and stores it in a list
plotTitle<-paste0("Normalized data distribution using ", NormType)
norm_Ptab<-arrangeGrob(grobs=NormHistList, ncol=ceiling(nrow(repl_meta[repl_selection,])/6)) #creates a table that organizes the plots
#png(paste0("./DistrPlots/norm", NormType, "_distPlot.png"), width=1600, height=800) #normCPM_distPlot
grid.arrange(norm_Ptab, legend_var, widths = c(10, 2.3), ncol=2, top=textGrob(plotTitle, gp=gpar(fontsize=20))) #plots the plot list and legend together
#dev.off()
if (exists("length_vec")){ #if we have lengths
length_vec<-data.frame(Length=length_vec) #convert to dataframe
dge <- DGEList(repl_data,genes=length_vec) #use edgeR for normalization
dge <- calcNormFactors(dge)
Nrepl_data <- rpkm(dge, log=TRUE)
Nrepl_data<-as.data.frame(Nrepl_data)
NormType<-"RPKM"
}
#Filter low expression genes
keep<-apply(Nrepl_data, 1, max)>=0 #keep genes where the counts for at least one replicate are of at least 1 (0 because of log)
Nrepl_data<-Nrepl_data[keep,]
#Nrepl to data frame
Nrepl_data<-as.data.frame(Nrepl_data) #evetually transpose
#More genes kept after normalization and filtering than cpm
NormHistList<-list() #to store the plots
for (i in 1:nrow(repl_meta[repl_selection,])){
color_var<-colorList[i]
loc<-colnames(repl_data)[i]
temp_plot<-multiColHist(Nrepl_data, loc, color_var)
NormHistList[[i]]<-temp_plot
} #iterates over each tissue, creates a plot with a distinct color for it and stores it in a list
plotTitle<-paste0("Normalized data distribution using ", NormType)
norm_Ptab<-arrangeGrob(grobs=NormHistList, ncol=ceiling(nrow(repl_meta[repl_selection,])/6)) #creates a table that organizes the plots
#png(paste0("./DistrPlots/norm", NormType, "_distPlot.png"), width=1600, height=800) #normRPKM_distPlot
grid.arrange(norm_Ptab, legend_var, widths = c(10, 2.3), ncol=2,  top=textGrob(plotTitle, gp=gpar(fontsize=20))) #plots the plot list and legend together
#dev.off()
#set genes as columns and replicates by species as rows
repl_dvData<-as.data.frame(t(repl_data))
Nrepl_dvData<-as.data.frame(t(Nrepl_data))
set.seed(42)
#Normalized
Nrepl_dvData_sc<-scale(Nrepl_dvData)
N_pca<-prcomp(Nrepl_dvData_sc, scale=T)
#Normalized
ggplot(N_pca$x, aes(x=PC1, y=PC2, color=repl_meta$org_location, shape=repl_meta$species))+
geom_point(size=6)+
scale_shape_manual(values = c(19, 1, 2, 15, 8))+
#scale_size_manual(values = c(2, 6))+
#scale_color_brewer(palette="Dark2")+
labs(title="Normalized PCA")+
theme_minimal()
#Tissue clusters
png("./ExprPlots/Expression_pca.png", width=1600, height=800)
#svg("./ExprPlots/Expression_pca.svg", width=1600/60, height=800/60)
fviz_pca_ind(N_pca, geom.ind = "point",
habillage = repl_meta$org_location, addEllipses = TRUE, pointshape = 19,
title="Tissue-based classification")+
xlab("")+ylab("")+
theme_bw()+
theme(legend.key.width=unit(1, "cm"),
legend.text=element_text(size=12),
legend.title=element_text(size=16),
panel.border=element_rect(linewidth=1),
panel.grid.major=element_line(color="grey"),
axis.ticks=element_line(colour="black"))
dev.off()
dataPlotter<-function(umap_data, metadata){
plt<-ggplot(as.data.frame(umap_data$layout), aes(x=umap_data$layout[,1], y=umap_data$layout[,2], shape=metadata$species, color=metadata$org_location))+
geom_point(size=8)+
scale_shape_manual(values = c(19, 1, 2, 15, 8))+
labs(x="", y="", shape="Lines", color="Tissue")+
theme_minimal()
return(plt)
}
sc_Numap_data<-umap(Nrepl_dvData_sc)
ggplotly(dataPlotter(sc_Numap_data, repl_meta)+ggtitle("Normalized-scaled data Umap"))
ggplotly(ggplot(as.data.frame(sc_Numap_data$layout), aes(x=sc_Numap_data$layout[,1], y=sc_Numap_data$layout[,2], color=repl_meta$org_location))+
geom_point(size=5)+
scale_shape_manual(values = c(19, 1, 2, 15, 8))+
theme_minimal()+ggtitle("Tissue-based"))
ggplot(as.data.frame(sc_Numap_data$layout), aes(x=sc_Numap_data$layout[,1], y=sc_Numap_data$layout[,2], color=repl_meta$species))+
geom_point(size=5)+
scale_shape_manual(values = c(19, 1, 2, 15, 8))+
theme_minimal()+ggtitle("Line-based")
FinalUmap<-umap(Nrepl_dvData_sc, n_neighbors=29, n_epochs=450, min_dist=0.1) #nneighbor:22, 29, 35
ggplotly(dataPlotter(FinalUmap, repl_meta)+geom_point(size=4)+ggtitle("Final UMAP with cleaned data"))
png("./ExprPlots/Expression_umap.png", width=1600, height=800)
#svg("./ExprPlots/Expression_umap.svg", width=1600/60, height=800/60)
dataPlotter(FinalUmap, repl_meta)+ggtitle("")+theme_bw()+
theme(axis.text.y=element_text(size=10),
legend.key.width=unit(1, "cm"),
legend.text=element_text(size=12),
legend.title=element_text(size=16),
panel.border=element_rect(linewidth=1),
panel.grid.major=element_line(color="gray"),
panel.grid.minor=element_blank())
dev.off()
#Convert to matrix
expression_matrix<-as.matrix(Nrepl_data)
sample_correlations<-cor(expression_matrix)
heatmaply(sample_correlations, clustering_method = "complete",
colors = blueWhiteRed(256),
#grid_color = "black",
grid_gap = 0.001)
Nrepl_data<-t(Nrepl_data)
power <- c(c(1:15), seq(from = 17, to = 50, by = 2)) #more detailed in lower values
#Network topology analysis
sft <- pickSoftThreshold(Nrepl_data,
powerVector = power,
networkType = "signed",
verbose = 5)
sftIn<-sft$fitIndices
p1<-ggplot(sftIn, aes(Power, SFT.R.sq, label = Power)) +
geom_point() +
geom_text(nudge_y = 0.1) +
geom_hline(yintercept = 0.8, color = 'red') +
labs(x = 'Power', y = 'Scale free topology model fit\nsigned R^2') +
theme_classic()
p2<-ggplot(sftIn, aes(Power, mean.k., label = Power)) +
geom_point() +
geom_text(nudge_y = 1500) +
labs(x = 'Power', y = 'Mean Connectivity') +
theme_classic()
grid.arrange(p1, p2, nrow=2)
#Use automatic calculation
print(sft$powerEstimate)
#If the automatic calculation is not valid or above the maximum for network clustering(30), use an alternative
if (is.na(sft$powerEstimate)){
softPw<-30 #if the soft power is NA, set to 30, else take smallest possible
}else{
softPw <- min(sft$powerEstimate, 30)
}
temp_cor<-cor
cor<-WGCNA::cor
ModNetwork<-blockwiseModules(Nrepl_data,
nThreads = 32, #16
maxBlockSize = 64000, #directly related to memory, if maxBlockSize<total genes, multiple blocks will have to be used -> worse clustering
deepSplit = 4,
TOMType = "unsigned", #unsigned?
power = softPw,
mergeCutHeight = 0.3,#0.3->4799#0.8->4799(low module granularity) #0.1->4799(high granularity(lots of colors))
minModuleSize = 20,
numericLabels = FALSE,
pamRespectsDendro = FALSE,
minKMEtoStay = 0.3,#0.3->4799 #0.8->7781 #<0.3 stays the same
randomSeed = 42,
verbose = 4)
cor<-temp_cor
module_eigengenes<-ModNetwork$MEs
#get number of genes for each module
table(ModNetwork$colors)
dim(Nrepl_data) #get total number of genes from the dimensions
MEg_data<-data.frame(ModNetwork$colors)
colnames(MEg_data)<-"modules"
#write.table(MEg_data, file="geneModule.txt")
#Plot the module colors before and after merging underneath
plotDendroAndColors(ModNetwork$dendrograms[[1]], cbind(ModNetwork$unmergedColors, ModNetwork$colors),
c("unmerged", "merged"),
dendroLabels = FALSE,
addGuide = TRUE,
hang= 0.03, #@@ review params
guideHang = 0.05)
module_eigengenes<-ModNetwork$MEs
#get number of genes for each module
table(ModNetwork$colors)
dim(Nrepl_data) #get total number of genes from the dimensions
MEg_data<-data.frame(ModNetwork$colors)
colnames(MEg_data)<-"modules"
#write.table(MEg_data, file="geneModule.txt")
max(table(ModNetwork$colors))
min(table(ModNetwork$colors))
mean(table(ModNetwork$colors))
