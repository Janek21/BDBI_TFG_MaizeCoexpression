metadata<-metadata[rownames(metadata) %in% colnames(data),] #remove metadata not present in data
cat("\nMetadata end with:" , dim(metadata), "\n")
options(warn=0)
return(list(data, metadata))
}
jointData<-dataMatcher(dataNL, metadata)
dataNL<-jointData[[1]]
metadata<-jointData[[2]]
#Should be all 0 due to preprocessing filtering
levels(as.factor(metadata$quality))
#Mapped abreviations
levels(metadata$tissue_abv)
#reps 1,2,3 and 4, is there an imbalance?
table(metadata$rep)
levels(metadata$location)
#Different rep aoumts indicate different amount of each replicate
table(metadata$location)
#there are different total numbers of tissue replicates
#Solve it by using 1 replicate per tissue (mean of exisitng replicates)
#@@ may not be a good idea to remove genes
outDetect<-goodSamplesGenes(t(dataNL))
table(outDetect$goodGenes) #False genes are outliers
table(outDetect$goodSamples) #All samples are True = no outliers
dataNL<-dataNL[outDetect$goodGenes==TRUE,] #remove ouliers
htree<-hclust(dist(t(dataNL)), method = "average")
plot(htree)
#B73: B73_23_2 and B73_MAT_3
#dataNL<-dataNL[,!(colnames(dataNL) %in% "B73_23_2")]
rsumer<-function(data, metadata, tissue_name){ #calculates the mean of all columns that belong to a location (mean of all COB columns)
loc_mdata<-metadata[metadata$location == tissue_name, ] #filter metadata tissue (get metadata of location only)
data<-data[,colnames(data) %in% rownames(loc_mdata)] #get data of lcoation only, based on metadata
data<-rowMeans(data) #calculate mean for each gene out of the locations(replicates)
return(as.data.frame(data))
}
tissue_data<-levels(metadata$location) #get list of tissue names
d_joint<-sapply(tissue_data, function(tissue_name) rsumer(dataNL, metadata, tissue_name)) #returns an array where each entry is a column with the mean data of the replicates (rows are genes)
repl_data<-as.data.frame(d_joint) #data joint by replicate
colnames(repl_data) = gsub(pattern = "*.data", replacement = "", x = tolower(colnames(repl_data))) #get column names to be only location
rownames(repl_data)<-rownames(dataNL) #rename rows to be genes again
#@@ dcide norm method
#uses edgeR
dge <- DGEList(repl_data)
# Calculate normalization factors
dge <- calcNormFactors(dge, method = "TMM")
# Get normalized counts
Nrepl_data <- cpm(dge)
View(Nrepl_data)
View(Nrepl_data)
lib_sizes <- colSums(repl_data)
# Calculate CPM
Nrepl_data <- (t(repl_data) / lib_sizes) * 1e6 #1e6 converts to a per million units, its more readable
View(Nrepl_data)
lib_sizes <- colSums(repl_data)
# Calculate CPM
Nrepl_data <- (t(repl_data) / lib_sizes) * 1e6 #1e6 converts to a per million units, its more readable
View(Nrepl_data)
knitr::opts_chunk$set(echo = TRUE)
library(WGCNA)
allowWGCNAThreads()
#library(DESeq2)
library(edgeR)
library(tidyverse)
library(dplyr)
library(gridExtra)
library(CorLevelPlot)
dataNL<-read.delim("../data/B73.csv", row.names=1, stringsAsFactors=TRUE)
metadata<-read.delim("../data/B73_m.txt", header=T, row.names=1, stringsAsFactors=TRUE)
#dataNL<-read.delim("../data/data_nolen.csv", row.names=1, stringsAsFactors=TRUE)
#metadata<-read.delim("../data/metadata_3.txt", header=T, row.names=1, stringsAsFactors=TRUE)
colnames(metadata)<-c("specie", "quality", "tissue_abv", "rep", "location")
dim(dataNL)
dim(metadata)
dataMatcher<-function(data, metadata){
options(warn=-1)
cat("Data begins with:" , dim(data))
cat("\nMetadata begins with:", dim(metadata))
#Match data to metadata
data <- data[, order(colnames(data))]
metadata <- metadata[order(rownames(metadata)), ]
cat("\nColumns data = Rows of metatdata?", all(rownames(metadata) == colnames(data)))
#If TRUE, columns of data and rows of metadata are matched
cat("\nRemove the excess from data")
data<-data[,colnames(data) %in% rownames(metadata)] #remove data not present in metadata
cat("\nData end with:" , dim(data))
cat("\nRemove the excess from metadata")
metadata<-metadata[rownames(metadata) %in% colnames(data),] #remove metadata not present in data
cat("\nMetadata end with:" , dim(metadata), "\n")
options(warn=0)
return(list(data, metadata))
}
jointData<-dataMatcher(dataNL, metadata)
dataNL<-jointData[[1]]
metadata<-jointData[[2]]
#Should be all 0 due to preprocessing filtering
levels(as.factor(metadata$quality))
#Mapped abreviations
levels(metadata$tissue_abv)
#reps 1,2,3 and 4, is there an imbalance?
table(metadata$rep)
levels(metadata$location)
#Different rep aoumts indicate different amount of each replicate
table(metadata$location)
#there are different total numbers of tissue replicates
#Solve it by using 1 replicate per tissue (mean of exisitng replicates)
#@@ may not be a good idea to remove genes
outDetect<-goodSamplesGenes(t(dataNL))
table(outDetect$goodGenes) #False genes are outliers
table(outDetect$goodSamples) #All samples are True = no outliers
dataNL<-dataNL[outDetect$goodGenes==TRUE,] #remove ouliers
htree<-hclust(dist(t(dataNL)), method = "average")
plot(htree)
#B73: B73_23_2 and B73_MAT_3
#dataNL<-dataNL[,!(colnames(dataNL) %in% "B73_23_2")]
rsumer<-function(data, metadata, tissue_name){ #calculates the mean of all columns that belong to a location (mean of all COB columns)
loc_mdata<-metadata[metadata$location == tissue_name, ] #filter metadata tissue (get metadata of location only)
data<-data[,colnames(data) %in% rownames(loc_mdata)] #get data of lcoation only, based on metadata
data<-rowMeans(data) #calculate mean for each gene out of the locations(replicates)
return(as.data.frame(data))
}
tissue_data<-levels(metadata$location) #get list of tissue names
d_joint<-sapply(tissue_data, function(tissue_name) rsumer(dataNL, metadata, tissue_name)) #returns an array where each entry is a column with the mean data of the replicates (rows are genes)
repl_data<-as.data.frame(d_joint) #data joint by replicate
colnames(repl_data) = gsub(pattern = "*.data", replacement = "", x = tolower(colnames(repl_data))) #get column names to be only location
rownames(repl_data)<-rownames(dataNL) #rename rows to be genes again
lib_sizes <- colSums(repl_data)
# Calculate CPM
Nrepl_data <- (t(repl_data) / lib_sizes) * 1e6 #1e6 converts to a per million units, its more readable
View(Nrepl_data)
#@@ dcide norm method
#uses edgeR
dge <- DGEList(repl_data)
# Calculate normalization factors
dge <- calcNormFactors(dge, method = "TMM")
# Get normalized counts
Nrepl_data <- cpm(dge)
View(Nrepl_data)
View(Nrepl_data)
lib_sizes <- colSums(repl_data)
# Calculate CPM
Nrepl_data <- (t(repl_data) / lib_sizes) * 1e6 #1e6 converts to a per million units, its more readable
#@@ dcide norm method
#uses edgeR
dge <- DGEList(repl_data)
# Calculate normalization factors
dge <- calcNormFactors(dge, method = "TMM")
# Get normalized counts
Nrepl_data <- cpm(dge)
View(Nrepl_data)
View(Nrepl_data)
View(repl_data)
hist(Nrepl_data)
#@@ dcide norm method
#uses edgeR
dge <- DGEList(repl_data)
#Calculate normalization factors
dge <- calcNormFactors(dge, method = "TMM")
#Get normalized counts #@@log2 cpm
Nrepl_data <- cpm(log2(dge))
View(dataNL)
hist(dataNL)
View(repl_meta)
View(dataNL)
View(metadata)
hist(dataNL$B73_19_1)
hist(dataNL$B73_19_2)
hist(dataNL$B73_19_1)
hist(Nrepl_data$cob)
a<-as.data.frame(Nrepl_data)
hist(a$cob)
hist(log2(a$cob))
lib_sizes <- colSums(repl_data)
#Calculate CPM
Nrepl_data <- (t(repl_data) / lib_sizes) * 1e6 #1e6 converts to a per million units, its more readable
hist(a$cob)
hist(log2(a$cob)
hist(log2(a$cob)
a<-as.data.frame(Nrepl_data)
hist(a$cob)
knitr::opts_chunk$set(echo = TRUE)
library(WGCNA)
allowWGCNAThreads()
#library(DESeq2)
library(edgeR)
library(tidyverse)
library(dplyr)
library(gridExtra)
library(CorLevelPlot)
dataNL<-read.delim("../data/B73.csv", row.names=1, stringsAsFactors=TRUE)
metadata<-read.delim("../data/B73_m.txt", header=T, row.names=1, stringsAsFactors=TRUE)
#dataNL<-read.delim("../data/data_nolen.csv", row.names=1, stringsAsFactors=TRUE)
#metadata<-read.delim("../data/metadata_3.txt", header=T, row.names=1, stringsAsFactors=TRUE)
colnames(metadata)<-c("specie", "quality", "tissue_abv", "rep", "location")
dim(dataNL)
dim(metadata)
dataMatcher<-function(data, metadata){
options(warn=-1)
cat("Data begins with:" , dim(data))
cat("\nMetadata begins with:", dim(metadata))
#Match data to metadata
data <- data[, order(colnames(data))]
metadata <- metadata[order(rownames(metadata)), ]
cat("\nColumns data = Rows of metatdata?", all(rownames(metadata) == colnames(data)))
#If TRUE, columns of data and rows of metadata are matched
cat("\nRemove the excess from data")
data<-data[,colnames(data) %in% rownames(metadata)] #remove data not present in metadata
cat("\nData end with:" , dim(data))
cat("\nRemove the excess from metadata")
metadata<-metadata[rownames(metadata) %in% colnames(data),] #remove metadata not present in data
cat("\nMetadata end with:" , dim(metadata), "\n")
options(warn=0)
return(list(data, metadata))
}
jointData<-dataMatcher(dataNL, metadata)
dataNL<-jointData[[1]]
metadata<-jointData[[2]]
#Should be all 0 due to preprocessing filtering
levels(as.factor(metadata$quality))
#Mapped abreviations
levels(metadata$tissue_abv)
#reps 1,2,3 and 4, is there an imbalance?
table(metadata$rep)
levels(metadata$location)
#Different rep aoumts indicate different amount of each replicate
table(metadata$location)
#there are different total numbers of tissue replicates
#Solve it by using 1 replicate per tissue (mean of exisitng replicates)
#@@ may not be a good idea to remove genes
outDetect<-goodSamplesGenes(t(dataNL))
table(outDetect$goodGenes) #False genes are outliers
table(outDetect$goodSamples) #All samples are True = no outliers
dataNL<-dataNL[outDetect$goodGenes==TRUE,] #remove ouliers
rsumer<-function(data, metadata, tissue_name){ #calculates the mean of all columns that belong to a location (mean of all COB columns)
loc_mdata<-metadata[metadata$location == tissue_name, ] #filter metadata tissue (get metadata of location only)
data<-data[,colnames(data) %in% rownames(loc_mdata)] #get data of lcoation only, based on metadata
data<-rowMeans(data) #calculate mean for each gene out of the locations(replicates)
return(as.data.frame(data))
}
tissue_data<-levels(metadata$location) #get list of tissue names
d_joint<-sapply(tissue_data, function(tissue_name) rsumer(dataNL, metadata, tissue_name)) #returns an array where each entry is a column with the mean data of the replicates (rows are genes)
repl_data<-as.data.frame(d_joint) #data joint by replicate
colnames(repl_data) = gsub(pattern = "*.data", replacement = "", x = tolower(colnames(repl_data))) #get column names to be only location
rownames(repl_data)<-rownames(dataNL) #rename rows to be genes again
hist(dataNL$B73_19_1)
hist(repl_data$cob)
ggplot(repl_data, aes(x=cob))+geom_histogram()
ggplot(repl_data, aes(x=cob))+geom_line()
ggplot(repl_data, aes(x=cob))+geom_line(aes(fill=..count..),stat="bin",binwidth=1)
#@@ dcide norm method
#uses edgeR
dge <- DGEList(repl_data)
#Calculate normalization factors
dge <- calcNormFactors(dge, method = "TMM")
#Get normalized counts
Nrepl_data <- cpm(dge)
#transpose results
#@@ dcide norm method
#uses edgeR
dge <- DGEList(repl_data)
#Calculate normalization factors
dge <- calcNormFactors(dge, method = "TMM")
#Get normalized counts
Nrepl_data <- log2(cpm(dge))
#transpose results
View(Nrepl_data)
#Get normalized counts
Nrepl_data <- log2(rpkm(dge))
#@@ dcide norm method
#uses edgeR
dge <- DGEList(repl_data)
#Calculate normalization factors
dge <- calcNormFactors(dge, method = "TMM")
#Get normalized counts
Nrepl_data <- log2(rpkm(dge))
?calcNormFactors
#@@ dcide norm method
#uses edgeR
dge <- DGEList(repl_data)
#Calculate normalization factors
dge <- calcNormFactors(dge, method = "TMM")
#Get normalized counts
Nrepl_data <- cpm(dge, log=TRUE)
#transpose results
View(repl_data)
#@@ dcide norm method
#uses edgeR
dge <- DGEList(repl_data)
#Calculate normalization factors
dge <- calcNormFactors(dge, method = "TMM")
#Get normalized counts
Nrepl_data <- cpm(dge, log=TRUE)
View(Nrepl_data)
power<-c(c(1:15), seq(17, 50, by=2))
#Network topology analysis
sft <- pickSoftThreshold(Nrepl_data,
powerVector = power,
networkType = "signed",
verbose = 5)
Nrepl_data<-t(Nrepl_data)
power<-c(c(1:15), seq(17, 50, by=2))
#Network topology analysis
sft <- pickSoftThreshold(Nrepl_data,
powerVector = power,
networkType = "signed",
verbose = 5)
#@@ dcide norm method
#uses edgeR
dge <- DGEList(repl_data)
#Calculate normalization factors
dge <- calcNormFactors(dge, method = "TMM")
#Get normalized counts
Nrepl_data <- cpm(dge, log=TRUE)
Nrepl_data<-as.data.frame(t(Nrepl_data))
#@@ dcide norm method
#uses edgeR
dge <- DGEList(repl_data)
#Calculate normalization factors
dge <- calcNormFactors(dge, method = "TMM")
#Get normalized counts
Nrepl_data <- cpm(dge, log=TRUE)
Nrepl_data<-as.data.frame(Nrepl_data)
hist(Nrepl_data$cob)
#@@ dcide norm method
#uses edgeR
dge <- DGEList(repl_data)
#Calculate normalization factors
dge <- calcNormFactors(dge)
#Get normalized counts
Nrepl_data <- cpm(dge, log=TRUE)
Nrepl_data<-as.data.frame(Nrepl_data)
hist(Nrepl_data$cob)
Nrepl_data<-as.data.frame(log10(Nrepl_data))
#@@ dcide norm method
#uses edgeR
dge <- DGEList(repl_data)
#Calculate normalization factors
dge <- calcNormFactors(dge)
#Get normalized counts
Nrepl_data <- cpm(dge)
Nrepl_data<-as.data.frame(log10(Nrepl_data))
hist(Nrepl_data$cob)
#@@ dcide norm method
#uses edgeR
dge <- DGEList(repl_data)
#Calculate normalization factors
dge <- calcNormFactors(dge)
#Get normalized counts
Nrepl_data <- cpm(dge, log=TRUE)
Nrepl_data<-as.data.frame(Nrepl_data)
hist(Nrepl_data$cob)
#uses edgeR
dge <- DGEList(repl_data)
#Calculate normalization factors
dge <- calcNormFactors(dge, method="upperquartile")
#Get normalized counts
Nrepl_data <- cpm(dge, log=TRUE)
#
Nrepl_data<-as.data.frame(Nrepl_data)
hist(Nrepl_data$cob)
hist(Nrepl_data$cob)
ggplot(repl_data, aes(x=cob))+geom_density()
ggplot(repl_data, aes(x=cob))+geom_boxplot()
ggplot(repl_data, aes(y=cob))+geom_boxplot()
ggplot(repl_data, aes(y=cob, x=colnames(repl_data)))+geom_boxplot()
ggplot(repl_data, aes(y=cob))+geom_boxplot()
ggplot(repl_data, aes(x=cob))+geom_density()
ggplot(Nrepl_data, aes(x=cob))+geom_density()
ggplot(Nrepl_data, aes(x=cob))+geom_density()+geom_histogram()
ggplot(Nrepl_data, aes(x=cob))geom_histogram()
ggplot(Nrepl_data, aes(x=cob))+geom_histogram()
ggplot(Nrepl_data, aes(x=cob))+geom_hist()
ggplot(Nrepl_data, aes(x=cob))+geom_hist()
ggplot(Nrepl_data, aes(x=cob))+geom_bar()
ggplot(Nrepl_data, aes(x=cob))+geom_col()
ggplot(Nrepl_data, aes(x=cob))+geom_curve()
ggplot(Nrepl_data, aes(x=cob))+geom_histogram()
ggplot(Nrepl_data, aes(x=cob))+geom_histogram(binwidth = 5)
ggplot(Nrepl_data, aes(x=cob))+geom_histogram(binwidth = 2)
ggplot(Nrepl_data, aes(x=cob))+geom_histogram(binwidth = 1)
ggplot(Nrepl_data, aes(x=cob))+geom_histogram(binwidth = 2)
ggplot(Nrepl_data, aes(x=cob))+geom_density()
ggplot(repl_data, aes(x=cob))+geom_histogram(binwidth = 2)
multiColPlot<-function(data, group=5){
data
}
hist(repl_data$cob)
ggplot(repl_data, aes(x=cob))+geom_histogram(binwidth = 2)
ggplot(repl_data, aes(x=cob))+geom_histogram()
View(repl_data)
ggplot(data, aes(x=c("cob", "coleoptile")))+geom_histogram()
knitr::opts_chunk$set(echo = TRUE)
library(WGCNA)
allowWGCNAThreads()
#library(DESeq2)
library(edgeR)
library(tidyverse)
library(dplyr)
library(gridExtra)
library(CorLevelPlot)
dataNL<-read.delim("../data/B73.csv", row.names=1, stringsAsFactors=TRUE)
metadata<-read.delim("../data/B73_m.txt", header=T, row.names=1, stringsAsFactors=TRUE)
#dataNL<-read.delim("../data/data_nolen.csv", row.names=1, stringsAsFactors=TRUE)
#metadata<-read.delim("../data/metadata_3.txt", header=T, row.names=1, stringsAsFactors=TRUE)
colnames(metadata)<-c("specie", "quality", "tissue_abv", "rep", "location")
dim(dataNL)
dim(metadata)
dataMatcher<-function(data, metadata){
options(warn=-1)
cat("Data begins with:" , dim(data))
cat("\nMetadata begins with:", dim(metadata))
#Match data to metadata
data <- data[, order(colnames(data))]
metadata <- metadata[order(rownames(metadata)), ]
cat("\nColumns data = Rows of metatdata?", all(rownames(metadata) == colnames(data)))
#If TRUE, columns of data and rows of metadata are matched
cat("\nRemove the excess from data")
data<-data[,colnames(data) %in% rownames(metadata)] #remove data not present in metadata
cat("\nData end with:" , dim(data))
cat("\nRemove the excess from metadata")
metadata<-metadata[rownames(metadata) %in% colnames(data),] #remove metadata not present in data
cat("\nMetadata end with:" , dim(metadata), "\n")
options(warn=0)
return(list(data, metadata))
}
jointData<-dataMatcher(dataNL, metadata)
dataNL<-jointData[[1]]
metadata<-jointData[[2]]
#Should be all 0 due to preprocessing filtering
levels(as.factor(metadata$quality))
#Mapped abreviations
levels(metadata$tissue_abv)
#reps 1,2,3 and 4, is there an imbalance?
table(metadata$rep)
levels(metadata$location)
#Different rep aoumts indicate different amount of each replicate
table(metadata$location)
#there are different total numbers of tissue replicates
#Solve it by using 1 replicate per tissue (mean of exisitng replicates)
#@@ may not be a good idea to remove genes
outDetect<-goodSamplesGenes(t(dataNL))
table(outDetect$goodGenes) #False genes are outliers
table(outDetect$goodSamples) #All samples are True = no outliers
dataNL<-dataNL[outDetect$goodGenes==TRUE,] #remove ouliers
rsumer<-function(data, metadata, tissue_name){ #calculates the mean of all columns that belong to a location (mean of all COB columns)
loc_mdata<-metadata[metadata$location == tissue_name, ] #filter metadata tissue (get metadata of location only)
data<-data[,colnames(data) %in% rownames(loc_mdata)] #get data of lcoation only, based on metadata
data<-rowMeans(data) #calculate mean for each gene out of the locations(replicates)
return(as.data.frame(data))
}
tissue_data<-levels(metadata$location) #get list of tissue names
d_joint<-sapply(tissue_data, function(tissue_name) rsumer(dataNL, metadata, tissue_name)) #returns an array where each entry is a column with the mean data of the replicates (rows are genes)
repl_data<-as.data.frame(d_joint) #data joint by replicate
colnames(repl_data) = gsub(pattern = "*.data", replacement = "", x = tolower(colnames(repl_data))) #get column names to be only location
rownames(repl_data)<-rownames(dataNL) #rename rows to be genes again
repl_meta<-as.data.frame(rownames(repl_data))
colnames(repl_meta)<-c("location")
ggplot(data, aes(x=cob))+geom_histogram()+
facet_wrap(~location)
ggplot(repl_data, aes(x=cob))+geom_histogram()+
facet_wrap(~location)
ggplot(repl_data, aes(x=cob))+geom_histogram()+
facet_wrap(~repl_meta$location)
ggplot(repl_data, aes(x=cob))+geom_histogram()
ggplot(repl_data)+geom_histogram()+
facet_wrap(~repl_meta$location)
View(repl_meta)
a
View(repl_meta)
repl_meta<-as.data.frame(colnames(repl_data))
colnames(repl_meta)<-c("location")
ggplot(repl_data, aes(x=cob))+geom_histogram()+
facet_wrap(~repl_meta$location)
View(repl_meta)
ggplot(t(repl_data), aes(x=cob))+geom_histogram()+
facet_wrap(~repl_meta$location)
ggplot(t(repl_data), aes(x=metadata$location))+geom_histogram()+
facet_wrap(~repl_meta$location)
ggplot(t(repl_data), aes(x=Zm00001eb000010))+geom_histogram()+
facet_wrap(~repl_meta$location)
ggplot(t(repl_data), aes(x=Zm00001eb000010))+geom_histogram()+
facet_wrap(~repl_meta$location)
ggplot(t(repl_data), aes(x=repl_data[,1:5]))+geom_histogram()+
facet_wrap(~repl_meta$location)
repl_data[,1:5]
multiColPlot<-function(data, location){
ggplot(data, aes(x=location))+geom_histogram()
}
hist(repl_data$cob)
ggplot(t(repl_data), aes(x=repl_data[,1:5]))+geom_histogram()+
facet_wrap(~repl_meta$location)
ggplot(t(repl_data), aes(x=repl_data[,1:5]))+geom_histogram()+
facet_wrap(~repl_meta$location)
ggplot(t(repl_data), aes(x=repl_data[,1:31]))+geom_histogram()+
facet_wrap(~repl_meta$location)
ggplot(t(repl_data), aes(x=repl_data[,1:30]))+geom_histogram()+
facet_wrap(~repl_meta$location)
repl_data[,1:30]
d
ggplot(t(repl_data), aes(x=repl_data[,1]))+geom_histogram()+
facet_wrap(~repl_meta$location)
gc()
knitr::opts_chunk$set(echo = TRUE)
library(WGCNA)
allowWGCNAThreads()
library(randomcoloR)
library(edgeR)
library(tidyverse)
library(dplyr)
library(gridExtra)
library(CorLevelPlot)
install.packages("CorLevelPlot")
BiocManager::install("CorLevelPlot")
install.packages("CorLevelPlot")
